#!/usr/bin/env python3
"""
Test script to diagnose paragraph data parsing issues with LLM-generated metadata.

This script isolates the exact problem with ast.literal_eval parsing of paragraph_data
strings generated by the LLM, helping identify character encoding issues, malformed
syntax, or other parsing problems.
"""

import ast
import json
import logging
import re
from typing import Any, Dict, List

# Set up logging
logging.basicConfig(level=logging.DEBUG, format='%(levelname)s: %(message)s')
logger = logging.getLogger(__name__)

def analyze_string_characters(text: str, name: str = "string") -> None:
    """Analyze a string character by character to find problematic characters."""
    print(f"\n=== CHARACTER ANALYSIS FOR {name.upper()} ===")
    print(f"String length: {len(text)}")
    print(f"String type: {type(text)}")
    print(f"String repr: {repr(text)}")
    
    # Look for common problematic patterns
    problematic_patterns = [
        (r'[^\x00-\x7F]', 'Non-ASCII characters'),
        (r'[\x00-\x1F]', 'Control characters'),
        (r'[\u2018\u2019]', 'Smart quotes (single)'),
        (r'[\u201C\u201D]', 'Smart quotes (double)'),
        (r'[\u2013\u2014]', 'Em/En dashes'),
        (r'[\u00A0]', 'Non-breaking space'),
        (r'\\[^\\"]', 'Possible escape sequence issues'),
    ]
    
    for pattern, description in problematic_patterns:
        matches = list(re.finditer(pattern, text))
        if matches:
            print(f"\nâš ï¸  Found {description}:")
            for match in matches[:5]:  # Show first 5 matches
                char = match.group()
                pos = match.start()
                print(f"   Position {pos}: '{char}' (ord: {ord(char)}, hex: {hex(ord(char))})")
                # Show context around the character
                start = max(0, pos - 10)
                end = min(len(text), pos + 11)
                context = text[start:end]
                print(f"   Context: {repr(context)}")
            if len(matches) > 5:
                print(f"   ... and {len(matches) - 5} more")
    
    # Check for unmatched brackets/quotes
    brackets = {'[': ']', '{': '}', '(': ')'}
    quotes = ["'", '"']
    
    for open_bracket, close_bracket in brackets.items():
        open_count = text.count(open_bracket)
        close_count = text.count(close_bracket)
        if open_count != close_count:
            print(f"âš ï¸  Unmatched {open_bracket}{close_bracket}: {open_count} open, {close_count} close")
    
    for quote in quotes:
        count = text.count(quote)
        if count % 2 != 0:
            print(f"âš ï¸  Unmatched {quote} quotes: {count} (should be even)")

def test_ast_literal_eval(test_string: str, test_name: str) -> Any:
    """Test ast.literal_eval on a string and provide detailed error analysis."""
    print(f"\n=== TESTING AST.LITERAL_EVAL FOR {test_name.upper()} ===")
    
    try:
        result = ast.literal_eval(test_string)
        print(f"âœ… SUCCESS: Parsed successfully")
        print(f"Result type: {type(result)}")
        if isinstance(result, list):
            print(f"List length: {len(result)}")
            if result:
                print(f"First item type: {type(result[0])}")
                print(f"First item: {result[0]}")
        return result
    except Exception as e:
        print(f"âŒ FAILED: {type(e).__name__}: {e}")
        
        # Try to provide more specific error analysis
        if "unexpected EOF" in str(e):
            print("   â†’ Likely cause: Unmatched brackets, parentheses, or quotes")
        elif "invalid syntax" in str(e):
            print("   â†’ Likely cause: Malformed Python literal syntax")
        elif "malformed node" in str(e):
            print("   â†’ Likely cause: Invalid characters or unsupported syntax")
        
        return None

def test_json_loads(test_string: str, test_name: str) -> Any:
    """Test json.loads as an alternative parser."""
    print(f"\n=== TESTING JSON.LOADS FOR {test_name.upper()} ===")
    
    try:
        # Try to convert Python-style to JSON-style
        json_style = test_string.replace("'", '"').replace('True', 'true').replace('False', 'false').replace('None', 'null')
        result = json.loads(json_style)
        print(f"âœ… SUCCESS: Parsed successfully with JSON")
        print(f"Result type: {type(result)}")
        return result
    except Exception as e:
        print(f"âŒ FAILED: {type(e).__name__}: {e}")
        return None

def clean_and_test_string(test_string: str, test_name: str) -> Any:
    """Try various cleaning strategies and test parsing."""
    print(f"\n=== CLEANING STRATEGIES FOR {test_name.upper()} ===")
    
    # Strategy 1: Remove/replace problematic characters
    cleaned1 = test_string
    # Replace smart quotes
    cleaned1 = re.sub(r'[\u2018\u2019]', "'", cleaned1)
    cleaned1 = re.sub(r'[\u201C\u201D]', '"', cleaned1)
    # Replace em/en dashes
    cleaned1 = re.sub(r'[\u2013\u2014]', '-', cleaned1)
    # Replace non-breaking space
    cleaned1 = re.sub(r'[\u00A0]', ' ', cleaned1)
    # Remove other non-ASCII
    cleaned1 = re.sub(r'[^\x00-\x7F]', '', cleaned1)
    
    if cleaned1 != test_string:
        print("Strategy 1: Replace smart quotes, dashes, non-ASCII")
        result = test_ast_literal_eval(cleaned1, f"{test_name}_cleaned1")
        if result is not None:
            return result
    
    # Strategy 2: More aggressive cleaning
    cleaned2 = test_string
    # Remove control characters
    cleaned2 = re.sub(r'[\x00-\x1F]', '', cleaned2)
    # Normalize whitespace
    cleaned2 = re.sub(r'\s+', ' ', cleaned2)
    # Strip leading/trailing whitespace
    cleaned2 = cleaned2.strip()
    
    if cleaned2 != test_string:
        print("Strategy 2: Remove control chars, normalize whitespace")
        result = test_ast_literal_eval(cleaned2, f"{test_name}_cleaned2")
        if result is not None:
            return result
    
    # Strategy 3: Try to fix common syntax issues
    cleaned3 = test_string
    # Fix potential trailing commas in lists/dicts
    cleaned3 = re.sub(r',\s*]', ']', cleaned3)
    cleaned3 = re.sub(r',\s*}', '}', cleaned3)
    
    if cleaned3 != test_string:
        print("Strategy 3: Fix trailing commas")
        result = test_ast_literal_eval(cleaned3, f"{test_name}_cleaned3")
        if result is not None:
            return result
    
    return None

def main():
    """Main test function."""
    print("ğŸ§ª PARAGRAPH DATA PARSING DIAGNOSTIC TOOL")
    print("=" * 60)
    
    # Test case 1: Known problematic string from the logs
    problematic_string = """[{'text': 'JPMorgan Chase did not assume First Republic Bank's deposits or any other liabilities of First Republic Bank.', 'bullet_style': 'bullet', 'indent_level': 0}]"""
    
    print(f"\nğŸ“ Testing known problematic string...")
    analyze_string_characters(problematic_string, "problematic_string")
    result1 = test_ast_literal_eval(problematic_string, "problematic_string")
    
    if result1 is None:
        print("\nğŸ”§ Trying cleaning strategies...")
        result1 = clean_and_test_string(problematic_string, "problematic_string")
    
    # Test case 2: Simulated LLM output with potential issues
    llm_output_with_issues = """[{'text': 'This is a "smart quote" example with â€“ em dash', 'bullet_style': 'bullet'}, {'text': 'Another paragraph with\x00control chars', 'bullet_style': 'none'}]"""
    
    print(f"\nğŸ“ Testing simulated LLM output with issues...")
    analyze_string_characters(llm_output_with_issues, "llm_output_with_issues")
    result2 = test_ast_literal_eval(llm_output_with_issues, "llm_output_with_issues")
    
    if result2 is None:
        print("\nğŸ”§ Trying cleaning strategies...")
        result2 = clean_and_test_string(llm_output_with_issues, "llm_output_with_issues")
    
    # Test case 3: Valid baseline for comparison
    valid_string = """[{'text': 'This is a valid paragraph', 'bullet_style': 'bullet', 'indent_level': 0}, {'text': 'Another valid paragraph', 'bullet_style': 'none', 'indent_level': 0}]"""
    
    print(f"\nğŸ“ Testing valid baseline string...")
    result3 = test_ast_literal_eval(valid_string, "valid_baseline")
    
    # Test case 4: Interactive mode - allow user to input their own string
    print(f"\nğŸ“ Interactive mode - paste your problematic string:")
    print("(Press Enter twice to finish, or type 'skip' to skip)")
    
    user_input_lines = []
    while True:
        try:
            line = input()
            if line.lower().strip() == 'skip':
                break
            if line == '' and user_input_lines and user_input_lines[-1] == '':
                break
            user_input_lines.append(line)
        except (EOFError, KeyboardInterrupt):
            break
    
    if user_input_lines and not (len(user_input_lines) == 1 and user_input_lines[0].lower().strip() == 'skip'):
        user_string = '\n'.join(user_input_lines).strip()
        if user_string:
            print(f"\nğŸ“ Testing user-provided string...")
            analyze_string_characters(user_string, "user_string")
            result4 = test_ast_literal_eval(user_string, "user_string")
            
            if result4 is None:
                print("\nğŸ”§ Trying cleaning strategies...")
                result4 = clean_and_test_string(user_string, "user_string")
            
            # Try JSON parsing as alternative
            test_json_loads(user_string, "user_string")
    
    print(f"\nğŸ DIAGNOSTIC COMPLETE")
    print("=" * 60)
    
    # Summary
    if result1 is not None:
        print("âœ… Problematic string: PARSED SUCCESSFULLY")
    else:
        print("âŒ Problematic string: PARSING FAILED")
    
    if result3 is not None:
        print("âœ… Valid baseline: PARSED SUCCESSFULLY")
    else:
        print("âŒ Valid baseline: PARSING FAILED (unexpected!)")

if __name__ == "__main__":
    main()
