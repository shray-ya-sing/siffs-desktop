EXCEL_FORMULAS = f"""
# Excel Functions Summary

| Formula | Use Cases | Function Parameters | Examples | Notes |
|---------|-----------|-------------------|----------|-------|
| **SUM** | Add values from cells, ranges, or individual values | `SUM(number1, [number2], ...)` | `=SUM(A2:A10)` adds values in cells A2:10<br>`=SUM(A2:A10, C2:C10)` adds values in both ranges | Can mix individual values, cell references, and ranges |
| **SUMIF** | Sum values based on a single condition | `SUMIF(range, criteria, [sum_range])` | `=SUMIF(A2:A10, ">32", B2:B10)` sums B2:B10 where A2:A10 > 32<br>`=SUMIF(B2:B10, "apple*", C2:C10)` sums C2:C10 where B2:B10 starts with "apple" | If sum_range is omitted, Excel adds cells specified in range argument. Text criteria must be in double quotes. Supports wildcards ?, *, ~. |
| **SUMIFS** | Sum values based on multiple conditions | `SUMIFS(sum_range, criteria_range1, criteria1, [criteria_range2, criteria2], ...)` | `=SUMIFS(A2:A9,B2:B9,"=A*",C2:C9,"Tom")` sums A2:A9 where B2:B9 starts with "A" AND C2:C9 equals "Tom"<br>`=SUMIFS(A2:A9,B2:B9,"<>Bananas",C2:C9,"Tom")` sums A2:A9 where B2:B9 is not "Bananas" AND C2:C9 equals "Tom" | Up to 127 range/criteria pairs allowed. All criteria ranges must have same dimensions as sum_range. |
| **COUNTIFS** | Count cells that meet multiple criteria | `COUNTIFS(criteria_range1, criteria1, [criteria_range2, criteria2], ...)` | `=COUNTIFS(A2:A10, ">32", B2:B10, "apple")` counts cells where A2:A10 > 32 AND B2:B10 equals "apple" | Up to 127 range/criteria pairs allowed. All criteria ranges must have same number of rows and columns. Ranges don't need to be adjacent. |
| **COUNT** | Count the number of cells containing numbers | `COUNT(value1, [value2], ...)` | `=COUNT(A2:A10)` counts numeric values in range A2:A10<br>`=COUNT(A2:A10, C2:C10)` counts numeric values in both ranges | Up to 255 arguments allowed. Only numbers are counted - blank and text values are ignored. |
| **FILTER** | Filter data based on specified criteria | `FILTER(array, include, [if_empty])` | `=FILTER(A5:D20,C5:C20=H2,"")` returns all records where C5:C20 equals H2<br>`=FILTER(A5:D20,(C5:C20=H1)*(A5:A20=H2),"")` returns records meeting both conditions (AND)<br>`=FILTER(A5:D20,(C5:C20=H1)+(A5:A20=H2),"")` returns records meeting either condition (OR) | Use * for AND conditions, + for OR conditions. Third parameter defines what to return if no matches found. |
| **FILTER + SORT** | Filter and sort data simultaneously | `SORT(FILTER(array, criteria), [sort_index], [sort_order])` | `=SORT(FILTER(A5:D20,(C5:C20=H1)*(A5:A20=H2),""),4,-1)` filters data with multiple criteria AND sorts by column 4 in descending order | Combines FILTER and SORT functions. Sort_order: 1 for ascending, -1 for descending. |
| **RANDARRAY** | Generate an array of random numbers | `RANDARRAY([rows],[columns],[min],[max],[whole_number])` | `=RANDARRAY(5,3,1,100,TRUE)` creates 5x3 array of random whole numbers between 1-100 | All parameters are optional. whole_number: TRUE for integers, FALSE for decimals. |
| **SEQUENCE** | Generate a list of sequential numbers | `SEQUENCE(rows,[columns],[start],[step])` | `=SEQUENCE(5,6,INT(RAND()*100),INT(RAND()*100))` creates 5x6 array with random starting values<br>`=TEXT(DATE(YEAR(TODAY()),SEQUENCE(1,6),1),"mmm")` creates dynamic month headers | Can be combined with other functions like INT, RAND, TEXT, DATE for complex sequences. |
| **UNIQUE** | Return unique values from a list or range | `UNIQUE(array,[by_col],[exactly_once])` | `=UNIQUE(D2:D11)` returns unique values from range<br>`=UNIQUE(A1:C10,TRUE,FALSE)` returns unique columns | by_col: TRUE for columns, FALSE for rows. exactly_once: TRUE for values that occur exactly once. Returns dynamic array. |
| **SORT** | Sort contents of a range or array | `SORT(array,[sort_index],[sort_order],[by_col])` | `=SORT(A5:D20,2,-1)` sorts by column 2 in descending order | sort_index: column/row to sort by. sort_order: 1 ascending, -1 descending. by_col: FALSE for rows, TRUE for columns. Returns dynamic array. |
| **SORTBY** | Sort array by specified criteria | `SORTBY(array, by_array1, [sort_order1], [by_array2, sort_order2],...)` | `=SORTBY(D2:E9,D2:D9,1,E2:E9,-1)` sorts by first column ascending, then second descending | More flexible than SORT. Can sort by multiple criteria. Respects column additions/deletions better than SORT. |
| **IFS** | Check multiple conditions and return corresponding values | `IFS(logical_test1, value_if_true1, [logical_test2, value_if_true2],...)` | `=IFS(A1>90,"A",A1>80,"B",A1>70,"C",TRUE,"F")` assigns letter grades | Up to 127 test/value pairs. Replaces nested IF statements. Evaluates conditions in order. |
| **XLOOKUP** | Advanced lookup function | `XLOOKUP(lookup_value, lookup_array, return_array, [if_not_found], [match_mode], [search_mode])` | `=XLOOKUP(A2,B2:B10,C2:C10,"Not Found",0,1)` looks up value and returns from different column | match_mode: 0=exact, -1=exact or smaller, 1=exact or larger, 2=wildcard. search_mode: 1=first-to-last, -1=reverse, 2=binary ascending, -2=binary descending. |
| **XMATCH** | Return relative position of item in array | `XMATCH(lookup_value, lookup_array, [match_mode], [search_mode])` | `=XMATCH("Apple",A1:A10,0,1)` returns position of "Apple" in range | Same match_mode and search_mode options as XLOOKUP. Returns position number, not value. |
| **DATE** | Create date from year, month, day | `DATE(year,month,day)` | `=DATE(2024,12,25)` creates December 25, 2024 | Year 0-1899 adds to 1900. Month >12 adds months to year. Day >month days adds to next month. Stores as serial number. |
| **DATEDIF** | Calculate difference between dates | `DATEDIF(start_date,end_date,unit)` | `=DATEDIF(A1,B1,"Y")` returns complete years between dates | Units: "Y"=years, "M"=months, "D"=days, "MD"=days ignoring months/years, "YM"=months ignoring years, "YD"=days ignoring years. |
| **DATEVALUE** | Convert text date to serial number | `DATEVALUE(date_text)` | `=DATEVALUE("1/1/2008")` returns 39448 | Useful for converting text dates to actual dates for calculations. Time information is ignored. |
| **DAYS** | Calculate days between two dates | `DAYS(end_date, start_date)` | `=DAYS(B1,A1)` returns number of days between dates | Simple function for day calculations. |
| **EDATE** | Add/subtract months from date | `EDATE(start_date, months)` | `=EDATE(A1,6)` returns date 6 months after A1 | Positive months for future, negative for past. Useful for maturity/due dates. |
| **EOMONTH** | Return last day of month | `EOMONTH(start_date, months)` | `=EOMONTH(A1,0)` returns last day of current month | 0 for current month, positive for future months, negative for past months. |
| **NETWORKDAYS** | Calculate working days between dates | `NETWORKDAYS(start_date, end_date, [holidays])` | `=NETWORKDAYS(A1,B1,C1:C10)` excludes weekends and holidays | Excludes weekends automatically. holidays parameter for additional exclusions. |
| **WORKDAY** | Calculate workday from start date | `WORKDAY(start_date, days, [holidays])` | `=WORKDAY(A1,20,C1:C10)` returns date 20 working days after A1 | Positive days for future, negative for past. Excludes weekends and holidays. |
| **YEARFRAC** | Calculate fraction of year between dates | `YEARFRAC(start_date, end_date, [basis])` | `=YEARFRAC(A1,B1)` returns decimal fraction of year | Used for benefits calculations and pro-rating. |
| **HLOOKUP** | Horizontal lookup in table | `HLOOKUP(lookup_value, table_array, row_index_num, [range_lookup])` | `=HLOOKUP(A1,B1:F5,3,FALSE)` looks up value in first row, returns from row 3 | Similar to VLOOKUP but searches horizontally. range_lookup: TRUE for approximate, FALSE for exact. |
| **INDEX** | Return value from specific position | `INDEX(array, row_num, [column_num])` | `=INDEX(A1:C10,5,2)` returns value from row 5, column 2 | If array is single row/column, corresponding argument is optional. Can return entire row/column with 0. |
| **INDIRECT** | Return reference from text string | `INDIRECT(ref_text, [a1])` | `=INDIRECT("A"&B1)` creates reference from text | Useful for dynamic references. a1: TRUE for A1 style, FALSE for R1C1 style. External references need open workbooks. |
| **MATCH** | Find position of value in array | `MATCH(lookup_value, lookup_array, [match_type])` | `=MATCH(25,A1:A10,0)` returns position of 25 in range | match_type: 1=largest ≤ value, 0=exact match, -1=smallest ≥ value. Often used with INDEX. |
| **OFFSET** | Return reference offset from starting reference | `OFFSET(reference, rows, cols, [height], [width])` | `=OFFSET(A1,2,3,1,1)` returns reference 2 rows down, 3 columns right | Doesn't move cells, just returns reference. Can specify height/width of returned range. |
| **VLOOKUP** | Vertical lookup in table | `VLOOKUP(lookup_value, table_array, col_index_num, [range_lookup])` | `=VLOOKUP(A2,B2:D10,2,FALSE)` looks up value in first column, returns from column 2 | Most common lookup function. Lookup value must be in leftmost column. range_lookup: TRUE for approximate, FALSE for exact. |

## Key Notes:
- **Wildcards**: Use `?` for single character, `*` for multiple characters, `~` to escape wildcards
- **Text criteria**: Must be enclosed in double quotes
- **Multiple criteria in FILTER**: Use `*` for AND conditions, `+` for OR conditions
- **Range matching**: In SUMIFS/COUNTIFS, all criteria ranges must have the same dimensions
- **Up to 127 criteria pairs** allowed in SUMIFS and COUNTIFS
"""