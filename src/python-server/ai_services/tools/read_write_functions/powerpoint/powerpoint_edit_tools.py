def _fix_python_literal_quotes(text: str) -> str:
    """Fixes unescaped apostrophes in Python literal strings.
    
    This function specifically handles the case where text content within Python
    literals contains unescaped apostrophes that break ast.literal_eval parsing.
    
    Args:
        text: Python literal string that may contain unescaped apostrophes
        
    Returns:
        Fixed string with properly escaped apostrophes
    """
    import re
    
    def fix_text_value(match):
        """Fix apostrophes within a 'text': '...' value"""
        prefix = match.group(1)  # 'text': '
        content = match.group(2)  # the actual text content
        suffix = match.group(3)   # '
        
        # Escape apostrophes that aren't already escaped
        # Temporarily protect existing escapes
        content = content.replace("\\'", "___TEMP_ESCAPE___")
        # Escape unescaped apostrophes
        content = content.replace("'", "\\'")
        # Restore protected escapes
        content = content.replace("___TEMP_ESCAPE___", "\\'")
        
        return f"{prefix}{content}{suffix}"
    
    # Fix 'text' values specifically - pattern matches 'text': 'content with apostrophe's'
    # This regex handles the most common case where text content has unescaped apostrophes
    fixed_text = re.sub(r"('text':\s*')([^']*(?:\\'[^']*)*)(')(?=\s*[,}])", fix_text_value, text)
    
    # If that didn't fix it, try a more general approach
    if fixed_text.count("'") % 2 != 0:
        # Count quotes to see if we still have an odd number
        # Apply a broader fix for any long quoted strings (likely text content)
        def fix_long_strings(match):
            content = match.group(1)
            if len(content) > 15:  # Only fix long strings (likely text content)
                # Same escape logic as above
                content = content.replace("\\'", "___TEMP_ESCAPE___")
                content = content.replace("'", "\\'")
                content = content.replace("___TEMP_ESCAPE___", "\\'")
            return f"'{content}'"
        
        # Match any single-quoted string
        fixed_text = re.sub(r"'([^']*(?:\\'[^']*)*)'(?=\s*[,}\]])", fix_long_strings, fixed_text)
    
    return fixed_text

import re
import json
import logging
import os
from pathlib import Path
from typing import Dict, Optional, Any, List

# Configure logger
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.StreamHandler(),
    ]
)
logger = logging.getLogger(__name__)


def _sanitize_text_content(text: str) -> str:
    """
    Sanitize text content by removing HTML-like tags and converting to plain text.
    
    Args:
        text: Text content that may contain HTML-like formatting
        
    Returns:
        Plain text with HTML tags stripped and proper line breaks
    """
    if not text or not isinstance(text, str):
        return text
    
    # Remove HTML tags but preserve the text content
    # Handle common HTML tags that might be generated by LLM
    import re
    
    # Replace <p> tags with line breaks (but not the first one)
    text = re.sub(r'<p[^>]*>', '\n', text)
    text = re.sub(r'</p>', '', text)
    
    # Remove all other HTML tags
    text = re.sub(r'<[^>]+>', '', text)
    
    # Clean up multiple consecutive newlines
    text = re.sub(r'\n\s*\n', '\n', text)
    
    # Strip leading/trailing whitespace and newlines
    text = text.strip()
    
    # If text starts with a newline, remove it (from first <p> replacement)
    if text.startswith('\n'):
        text = text[1:]
    
    return text


def _parse_shape_properties(entry: str):
    """
    Parse shape properties from a comma-separated string, handling quoted values and brackets properly.
    
    Args:
        entry: String like "shape_name, prop1=value1, prop2="quoted value", table_data="[['A', 'B'], ['C', 'D']]"
        
    Returns:
        A tuple containing the list of property strings and the extractions dictionary.
    """
    # First, extract bracketed content and JSON objects to avoid comma splitting issues
    import re
    
    # Dictionary to store extracted content
    extractions = {}
    bracket_counter = 0
    json_counter = 0
    
    def extract_brackets(match):
        """Extract bracketed content and replace with placeholder"""
        nonlocal bracket_counter
        content = match.group(1)
        placeholder = f"BRACKET_PLACEHOLDER_{bracket_counter}"
        extractions[placeholder] = content
        bracket_counter += 1
        return f"[{placeholder}]"
    
    def extract_json_objects(match):
        """Extract JSON object content and replace with placeholder"""
        nonlocal json_counter
        content = match.group(1)
        placeholder = f"JSON_PLACEHOLDER_{json_counter}"
        extractions[placeholder] = content
        json_counter += 1
        return f"{{{placeholder}}}"
    
    # Extract nested brackets for table properties
    # This regex handles nested brackets like [[...], [...]] 
    entry_with_placeholders = re.sub(r'\[([^\[\]]*(?:\[[^\[\]]*\][^\[\]]*)*)\]', extract_brackets, entry)
    
    # Extract JSON objects to avoid comma splitting issues
    # This regex handles nested JSON objects like {"key": ["val1", "val2"], "key2": [{"nested": "value"}]}
    entry_with_placeholders = re.sub(r'\{([^{}]*(?:\{[^{}]*\}[^{}]*)*)\}', extract_json_objects, entry_with_placeholders)
    
    # Now parse the entry with placeholders
    parts = []
    current_part = ""
    in_quotes = False
    quote_char = None
    
    i = 0
    while i < len(entry_with_placeholders):
        char = entry_with_placeholders[i]
        
        if char in ['"', "'"] and not in_quotes:
            # Start of quoted string
            in_quotes = True
            quote_char = char
            current_part += char
        elif char == quote_char and in_quotes:
            # End of quoted string
            in_quotes = False
            quote_char = None
            current_part += char
        elif char == ',' and not in_quotes:
            # Comma outside quotes - end of property
            if current_part.strip():
                parts.append(current_part.strip())
            current_part = ""
        else:
            current_part += char
        
        i += 1
    
    # Add the last part
    if current_part.strip():
        parts.append(current_part.strip())
    
    return parts, extractions


def _parse_property_value(value: str, extractions: Dict[str, str] = None) -> Any:
    """
    Parse a property value string into the appropriate Python type.
    
    Args:
        value: String value to parse
        extractions: Dictionary of placeholder -> content mappings for restoration
        
    Returns:
        Parsed value (str, int, float, bool, dict, list)
    """
    if not value:
        return value
    
    # Restore placeholders if extractions are provided (with recursive restoration)
    if extractions:
        # Recursive placeholder restoration to handle nested structures
        def restore_placeholders_recursive(text, extractions, max_iterations=10):
            """Recursively restore placeholders to handle nested structures."""
            for iteration in range(max_iterations):
                changed = False
                for placeholder, content in extractions.items():
                    if placeholder in text:
                        text = text.replace(placeholder, content)
                        changed = True
                if not changed:
                    break  # No more placeholders to replace
            return text
        
        value = restore_placeholders_recursive(value, extractions)
    
    # Handle backtick-wrapped values (remove backticks)
    if value.startswith('`') and value.endswith('`'):
        value = value[1:-1]
    
    # Handle quoted strings that contain JSON-like structures
    if (value.startswith('"') and value.endswith('"')) or (value.startswith("'") and value.endswith("'")):
        # Remove quotes
        text_value = value[1:-1]
        
        # Check if it's a JSON object or array (starts with { or [)
        if (text_value.startswith('{') and text_value.endswith('}')) or (text_value.startswith('[') and text_value.endswith(']')):
            try:
                import json
                # Try to parse as JSON - first attempt direct parsing
                return json.loads(text_value)
            except (json.JSONDecodeError, ValueError):
                # If JSON parsing fails, try unescaping quotes and parsing again
                try:
                    import json
                    # Handle escaped quotes in JSON strings
                    unescaped_text = text_value.replace('\\"', '"')
                    return json.loads(unescaped_text)
                except (json.JSONDecodeError, ValueError):
                    # If JSON parsing still fails, try ast.literal_eval for Python literal structures
                    try:
                        import ast
                        # Apply robust quote fixing before ast.literal_eval to handle unescaped apostrophes
                        fixed_text = _fix_python_literal_quotes(text_value)
                        return ast.literal_eval(fixed_text)
                    except (ValueError, SyntaxError) as e:
                        logger.warning(f"Could not parse Python literal '{text_value[:100]}...': {e}")
                        # If both fail, return as string
                        pass
        
        # Handle escape sequences for regular text
        text_value = text_value.replace('\\n', '\n')
        text_value = text_value.replace('\\t', '\t')
        text_value = text_value.replace('\\r', '\r')
        text_value = text_value.replace('\\\\', '\\')
        text_value = text_value.replace('\\"', '"')
        text_value = text_value.replace("\\'", "'")
        return text_value
    
    # Handle boolean values
    if value.lower() == 'true':
        return True
    elif value.lower() == 'false':
        return False
    
    # Handle numeric values
    try:
        # Try integer first
        if '.' not in value:
            return int(value)
        else:
            return float(value)
    except ValueError:
        pass
    
    # Handle hex colors (keep as string)
    if value.startswith('#') and len(value) == 7:
        return value
    
    # Handle unquoted JSON-like structures (fallback)
    if (value.startswith('{') and value.endswith('}')) or (value.startswith('[') and value.endswith(']')):
        try:
            import json
            return json.loads(value)
        except (json.JSONDecodeError, ValueError):
            try:
                import ast
                return ast.literal_eval(value)
            except (ValueError, SyntaxError):
                pass
    
    # Default to string
    return value


def parse_markdown_powerpoint_data(markdown_input: str) -> Optional[Dict[str, Dict[str, Any]]]:
    """
    Parse markdown-style PowerPoint shape data into a dictionary of slide data.
    
    Expected input format:
        slide_number: slide1 | shape_name, fill="#798798", out_col="#789786", out_style="solid", out_width=2, geom="rectangle", text="Sample text", font_size=14, bold=true
    
    Args:
        markdown_input: String in markdown format with slide and shape properties
        
    Returns:
        Dictionary with slide numbers as keys and shape properties as values if valid, None otherwise.
    """
    logger.info("Starting to parse markdown PowerPoint data")
    
    try:
        if not markdown_input or not isinstance(markdown_input, str):
            logger.error("Invalid markdown input: empty or not a string")
            return None

        result = {}

        # Split by 'slide_number:' to separate different slides
        slide_sections = [s.strip() for s in markdown_input.split('slide_number:') if s.strip()]

        for section in slide_sections:
            parts = [p.strip() for p in section.split('|', 1)]
            if not parts:
                continue

            slide_info = parts[0].strip()
            if not slide_info:
                logger.warning("Empty slide info found, skipping section")
                continue

            # Parse slide number and optional layout
            slide_number = slide_info
            slide_layout = None
            
            # Check if slide layout is specified in the slide info
            if ',' in slide_info:
                slide_parts = [p.strip() for p in slide_info.split(',')]
                slide_number = slide_parts[0]
                
                # Look for slide_layout specification in remaining parts
                for part in slide_parts[1:]:
                    if part.startswith('slide_layout='):
                        layout_value = part.replace('slide_layout=', '').strip()
                        # Remove quotes if present
                        if layout_value.startswith('"') and layout_value.endswith('"'):
                            layout_value = layout_value[1:-1]
                        elif layout_value.startswith("'") and layout_value.endswith("'"):
                            layout_value = layout_value[1:-1]
                        slide_layout = layout_value
                        logger.debug(f"Parsed slide layout '{slide_layout}' for slide {slide_number}")
                        break

            result[slide_number] = {}
            
            # Add slide layout if specified
            if slide_layout:
                result[slide_number]['_slide_layout'] = slide_layout
            
            # Check for slide deletion flag in slide info
            if 'delete_slide=true' in slide_info.lower() or 'delete_slide="true"' in slide_info.lower():
                result[slide_number]['_delete_slide'] = True
                logger.info(f"Parsed slide deletion request for slide {slide_number}")
                continue  # Skip shape processing for deleted slides

            if len(parts) == 1:  # No shape entries for this slide
                continue

            shape_entries = [e.strip() for e in parts[1].split('|') if e.strip()]
            
            # Track shape names within this slide to detect duplicates
            slide_shape_names = set()

            for entry in shape_entries:
                if not entry:
                    continue

                if entry.strip().startswith('delete_shapes:'):
                    try:
                        # Extract the list of shape names to delete
                        shapes_to_delete_str = entry.split(':', 1)[1].strip()
                        shapes_to_delete = _parse_property_value(shapes_to_delete_str)
                        if isinstance(shapes_to_delete, list):
                            if '_shapes_to_delete' not in result[slide_number]:
                                result[slide_number]['_shapes_to_delete'] = []
                            result[slide_number]['_shapes_to_delete'].extend(shapes_to_delete)
                            logger.info(f"Parsed delete request for shapes {shapes_to_delete} on slide {slide_number}")
                        else:
                            logger.warning(f"Could not parse list of shapes to delete: {entry}")
                    except Exception as e:
                        logger.error(f"Error parsing delete_shapes directive: {entry} - {e}")
                    continue

                # Parse shape entry: "shape_name, prop1=value1, prop2=value2, ..."
                shape_parts, extractions = _parse_shape_properties(entry)
                if not shape_parts:
                    continue
                
                # First part must be the shape name property
                first_part = shape_parts[0].strip()
                if not first_part.startswith('shape_name='):
                    logger.warning(f"Skipping shape entry because it does not start with shape_name=: {entry}")
                    continue

                # Extract shape name
                try:
                    shape_name = re.match(r'shape_name=\"(.*?)\"', first_part).group(1)
                except (AttributeError, IndexError):
                    logger.warning(f"Could not parse shape_name from entry: {entry}")
                    continue
                
                shape_name = shape_name.strip()
                if not shape_name:
                    continue
                
                # Rest are properties
                shape_data = {}
                for prop in shape_parts[1:]:
                    if '=' in prop:
                        key_value = prop.split('=', 1)
                        if len(key_value) == 2:
                            key, value = key_value
                            key = key.strip()
                            value = value.strip()
                            
                            # Parse the value based on its type
                            parsed_value = _parse_property_value(value, extractions)
                            
                            # Convert geometry property to lowercase for consistency
                            if key == 'geom' and isinstance(parsed_value, str):
                                parsed_value = parsed_value.lower()
                            
                            # Sanitize text content to remove HTML-like formatting
                            if key == 'text' and isinstance(parsed_value, str):
                                parsed_value = _sanitize_text_content(parsed_value)
                                logger.debug(f"Sanitized text content for shape '{shape_name}': '{parsed_value[:50]}...'")
                            
                            # Normalize chart data to ensure consistent 'values' key usage
                            if key == 'chart_data' and isinstance(parsed_value, dict):
                                series_list = parsed_value.get('series', [])
                                for series in series_list:
                                    if isinstance(series, dict):
                                        # If series has 'data' key but not 'values', normalize it
                                        if 'data' in series and 'values' not in series:
                                            series['values'] = series.pop('data')
                                            logger.debug(f"Normalized chart series 'data' key to 'values' for shape '{shape_name}'")
                                        # Also handle other possible keys that should be 'values'
                                        elif 'series_data' in series and 'values' not in series:
                                            series['values'] = series['series_data']
                                            del series['series_data']
                                            logger.debug(f"Normalized chart series 'series_data' key to 'values' for shape '{shape_name}'")
                                        elif 'numbers' in series and 'values' not in series:
                                            series['values'] = series['numbers']
                                            del series['numbers']
                                            logger.debug(f"Normalized chart series 'numbers' key to 'values' for shape '{shape_name}'")
                            
                            # Handle paragraphs property - extract text content and preserve formatting
                            if key == 'paragraphs' and isinstance(parsed_value, list):
                                # Extract text content from paragraphs and combine into a single text property
                                text_lines = []
                                for paragraph in parsed_value:
                                    if isinstance(paragraph, dict) and 'text' in paragraph:
                                        text_lines.append(paragraph['text'])
                                
                                # Combine all paragraph text into a single text property
                                if text_lines:
                                    combined_text = '\n'.join(text_lines)
                                    shape_data['text'] = combined_text
                                    logger.debug(f"Extracted text content from paragraphs for shape '{shape_name}': '{combined_text[:100]}...'")
                                
                                # Keep the original paragraphs data for formatting purposes
                                # The writer can use this for advanced paragraph-level formatting
                                logger.debug(f"Preserved paragraphs formatting data for shape '{shape_name}': {len(parsed_value)} paragraphs")
                            
                            shape_data[key] = parsed_value
                            
                            # Log advanced text formatting properties for debugging
                            if key in ['bullet_style', 'bullet_char', 'indent_level', 'left_indent', 'right_indent', 
                                     'first_line_indent', 'space_before', 'space_after', 'line_spacing']:
                                logger.debug(f"Parsed advanced text formatting property '{key}' = '{parsed_value}' for shape '{shape_name}'");

                if shape_name:
                    result[slide_number][shape_name] = shape_data
                    logger.debug(f"Parsed shape '{shape_name}' for slide {slide_number} with properties: {shape_data}")

        if not result:
            logger.error("No valid slides or shape entries found in markdown")
            return None

        logger.info(f"Successfully parsed shape data for {len(result)} slides from markdown")
        return result

    except Exception as e:
        logger.error(f"Error in parse_markdown_powerpoint_data: {str(e)}", exc_info=True)
        return None


def update_powerpoint_cache(workspace_path: str, updated_shapes: List[Dict[str, Any]]) -> bool:
    """
    Update the PowerPoint metadata cache with modified shape data.

    Args:
        workspace_path: Full path to the PowerPoint file in the format 'folder/presentation.pptx'
        updated_shapes: List of dicts with updated shape information returned from PowerPoint writer.
                       Each dict contains:
                       {
                           'shape_name': str,
                           'slide_number': int,
                           'properties_applied': List[str]
                       }

    Returns:
        bool: True if at least one shape was updated successfully, False otherwise.
    """
    try:
        # Define paths
        current_path = Path(__file__).parent.parent.parent.parent.parent
        cache_file = current_path / "metadata" / "_cache" / "powerpoint_metadata_hotcache.json"
        mappings_file = current_path / "metadata" / "__cache" / "files_mappings.json"

        # Get the temp file path from mappings
        try:
            with open(mappings_file, 'r') as f:
                mappings = json.load(f)
            temp_file_path = mappings.get(workspace_path) or next(
                (v for k, v in mappings.items() if k.endswith(Path(workspace_path).name)), 
                workspace_path
            )
        except (json.JSONDecodeError, OSError) as e:
            logger.error(f"Error loading file mappings: {str(e)}")
            temp_file_path = workspace_path

        # Load existing cache
        if not cache_file.exists():
            logger.error("PowerPoint cache file not found")
            return False

        with open(cache_file, 'r+', encoding='utf-8') as f:
            try:
                cache_data = json.load(f)
            except json.JSONDecodeError as e:
                logger.error(f"Invalid PowerPoint cache file format: {str(e)}")
                return False

            file_name = os.path.basename(temp_file_path)
            presentation_updated = False
            success_count = 0
            error_count = 0
            
            # Find the presentation in the cache
            for cache_key, presentation_data in cache_data.items():
                if not isinstance(presentation_data, dict):
                    continue
                
                # Check if this is the right presentation by matching file path or name
                if (presentation_data.get('file_path') == temp_file_path or 
                    presentation_data.get('workspace_path') == workspace_path or
                    presentation_data.get('presentation_name') == file_name):
                    
                    presentation_updated = True
                    
                    # Process each updated shape
                    for shape_info in updated_shapes:
                        try:
                            slide_number = shape_info.get('slide_number')
                            shape_name = shape_info.get('shape_name')
                            properties_applied = shape_info.get('properties_applied', [])
                            
                            if not slide_number or not shape_name:
                                error_count += 1
                                continue
                            
                            # Find the slide within the presentation
                            slides = presentation_data.get('slides', [])
                            slide_found = False
                            target_slide = None
                            
                            for slide in slides:
                                if slide.get('slideNumber') == slide_number:
                                    slide_found = True
                                    target_slide = slide
                                    break
                            
                            if not slide_found:
                                # Create new slide if it doesn't exist
                                logger.info(f"Creating new slide {slide_number} in cache")
                                target_slide = {
                                    'slideNumber': slide_number,
                                    'slideId': f'slide_{slide_number}',
                                    'name': f'Slide {slide_number}',
                                    'layoutName': 'Title and Content',
                                    'shapes': [],
                                    'notes': {'hasNotes': False},
                                    'comments': []
                                }
                                slides.append(target_slide)
                                slide_found = True
                            
                            if slide_found and target_slide:
                                # Find the shape within the slide
                                shapes = target_slide.get('shapes', [])
                                shape_found = False
                                
                                for shape in shapes:
                                    if shape.get('name') == shape_name:
                                        shape_found = True
                                        
                                        # Update existing shape metadata with applied properties
                                        if 'editingHistory' not in shape:
                                            shape['editingHistory'] = []
                                        
                                        # Add a new editing record
                                        from datetime import datetime
                                        editing_record = {
                                            'timestamp': datetime.now().isoformat(),
                                            'properties_applied': properties_applied
                                        }
                                        shape['editingHistory'].append(editing_record)
                                        
                                        # Also update the last modified timestamp
                                        shape['lastModified'] = datetime.now().isoformat()
                                        
                                        success_count += 1
                                        logger.debug(f"Updated existing shape '{shape_name}' in slide {slide_number}")
                                        break
                                
                                if not shape_found:
                                    # Create new shape in cache
                                    logger.info(f"Adding new shape '{shape_name}' to slide {slide_number} in cache")
                                    from datetime import datetime
                                    
                                    new_shape = {
                                        'shapeIndex': len(shapes),
                                        'shapeId': f'shape_{len(shapes) + 1}',
                                        'name': shape_name,
                                        'shapeType': 'AUTO_SHAPE',  # Default type
                                        'position': {
                                            'left': 100,
                                            'top': 100,
                                            'width': 100,
                                            'height': 100,
                                            'leftInches': 1.39,
                                            'topInches': 1.39,
                                            'widthInches': 1.39,
                                            'heightInches': 1.39
                                        },
                                        'rotation': 0,
                                        'visible': True,
                                        'zOrder': len(shapes) + 1,
                                        'textContent': {
                                            'hasText': False,
                                            'text': '',
                                            'paragraphs': [],
                                            'runs': []
                                        },
                                        'fill': {'type': 'none'},
                                        'line': {'type': 'none'},
                                        'shadow': {'visible': False},
                                        'editingHistory': [{
                                            'timestamp': datetime.now().isoformat(),
                                            'properties_applied': properties_applied
                                        }],
                                        'lastModified': datetime.now().isoformat(),
                                        'created': datetime.now().isoformat()
                                    }
                                    
                                    shapes.append(new_shape)
                                    success_count += 1
                                    logger.debug(f"Added new shape '{shape_name}' to slide {slide_number}")
                                
                        except Exception as shape_error:
                            error_count += 1
                            logger.error(f"Error updating shape {shape_info.get('shape_name', 'unknown')}: {str(shape_error)}", 
                                       exc_info=True)
                            continue
                    
                    # Update the presentation's last modified timestamp
                    if success_count > 0:
                        from datetime import datetime
                        presentation_data['lastModified'] = datetime.now().isoformat()
                        presentation_data['file_mtime'] = os.path.getmtime(temp_file_path) if os.path.exists(temp_file_path) else None
                    
                    break
            
            if not presentation_updated:
                logger.error(f"No matching presentation found for {file_name}")
                return False
                
            if success_count == 0 and error_count > 0:
                logger.error("All shape updates failed")
                return False
                
            # Write back to the file
            try:
                f.seek(0)
                json.dump(cache_data, f, indent=2, ensure_ascii=False, default=str)
                f.truncate()
                logger.info(f"PowerPoint cache updated successfully: {success_count} shapes updated, {error_count} errors")
                return True
            except Exception as write_error:
                logger.error(f"Error writing to PowerPoint cache file: {str(write_error)}", exc_info=True)
                return False
                
    except Exception as e:
        logger.error(f"Error updating PowerPoint cache: {str(e)}", exc_info=True)
        return False
